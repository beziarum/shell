\documentclass[12pt]{article}

\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{alltt}
\usepackage{tocbibind}


\title{Rapport Projet Programmation Système}
\author{Beziau Paul, Bazalgette Martin, Borde Antoine}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{Présentation}

L'objectif de ce projet étais d'implémenter un shell capable d'interpréter les expression de base
utilisable avec bash et d'éxétcuter des procéssus. En réalité une bonne partie du code du shell
nous été deja fournit. Tout l'aspect de l'analyse syntaxique été déja implémenté dans les fichier
donné dans le sujet.\newline

On peut diviser le travail à effectuer en 4 partie qui sont:
\begin{itemize}
 \item Implémenter la possibilité pour notre shell d'éxécuter des
 commande externe ou des progrmme en tout genre n'appartenant pas au shell
 \item Donner au shell la capacité d'interpréter les expression courante
 utilisable sous bash, comme les redirections ou les pipes
 \item Ecrire un certain nombre de commande interne (des fonctions appartennant
 au shell en lui meme) tout en faisant attention à les rendre utilisable avec
 les expressions précédement cité
 \item L'implémentation d'une commande interne "remote" qui nous permetra d'éxécuter
 et controler des shells distants en utilisant ssh.\newline 
\end{itemize}

Nous verrons au travers de ce rapport comment nous avons choisit d'implémenter ces différentes
fonctionnalité.

\newpage
\section{Commande externe}
 
 Le début de ce projet avait deja été bien entammé en tp. Nous nous somme donc
 inspiré de se qui avait été fait en classe. Nous avons créer une structure contexte
 qui contiendra a therme tout les elements dont nous auront besoin. 
 
 Ensuite nous avons implémenté une deuxieme structure assoc qui posséde un champ expr\_t
 et un pointeur de fonction reliant le type d'expréssion a la fonction de traitement
 qui lui est associé.
 
 \subsection{Commande simple en avant plan}
 
 L'éxécution de commande simple en avant plan est implémenté avec un simple fork().
 On récupére les arguments de la commande rentré et on fait un execvp de cette commande
 avec ces parametres du coté de fils. Pendant ce temps le pere attend la fin de l'éxécution
 et récupére la valeur de retour de son fils.
 
 

\newpage
\section{Expression}


\newpage
\section{Commande interne}

Dans cette partie nous avons du implémenter directement le comportement de quelques
commandes dans notre shell. Ces commandes n'etaient pas trés difficiles à implémenter. La plupart
du temps il suffisait de trouver le bon appél systeme à utilisé. A noter tout de même
que nous n'avons implémenté que les fonctionnalités de base offertes par ces commandes, nous
ne nous sommes pas amusés à ajouter la gestion de tout les paramètres, ce qui aurait 
représenté un travail trés fastidieux.

\subsection{Fonction}
\subsubsection{echo}
 La commande echo n'est rien d'autre qu'une fonction qui écrit les paramètres qu'elle reçoit
 sur la sortie standard. Un simple printf suffit pour cette commande.
 
\subsubsection{date}
 Pour cette commande nous avons du faire quelques recherches sur les fonctions fournies par time.h.
 Nous avons décidé de créer une structure tm et d'utiliser la fonction strftime qui
 sert justement à afficher l'heure selon son propre format qu'on peut définir à la volée.
 
 \subsubsection{cd}
 La commande cd à requis d'utiliser l'appel systeme chdir qui ouvre le repertoir passé en paramètre
 Nous avons veillés à récupérer la variable d'environement HOME avec getenv pour les cas ou cd est
 appellé sans paramètre. Nous avons également tenté de prévenir d'éventuels erreures(comme les
 répertoire non existant).
 
 \subsubsection{pwd}
 Cette commande à juste besoin de recupérer le répertoire courant nous avons donc utilisé
 la fonction getcwd qui retourne ce dernier. La taille maximale du buffer acceuillant le chemin
 du repertoire est....
 
 \subsubsection{hostname}
 
 \subsubsection{exit}
 
 \subsubsection{kill}
 Pour la commande kill nous avons simplement utilisé l'appel systeme kill. Notre commande
 peut gérer le paramètre de choix de signal à envoyer. Il peut l'envoyer à tous les processus
 rentré en paramètres.
 Pour gérer l'erreur en cas d'absence de paramètres nous avons touchés directement à la valeure
 de errno la passant à EINVAL (invalid argument).
 
 \subsubsection{history}
 
 \subsection{Intégration au shell}
 
 La difficultée de cette partie n'était pas tant l'implémentation des fonctions en elles mêmes,
 mais surtout le fait de rendre compatible tout ce qui avait été fait avant avec ces commandes.
 En effet les commandes internes n'utilisent pas de fork il faut donc gérer leurs comportements
 de manière particulière.

\newpage
\section{Remote shell}


\newpage
\section{Conclusion}



\end{document}
