\documentclass[12pt]{article}

\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{alltt}
\usepackage{tocbibind}


\title{Rapport Projet Programmation Système}
\author{Beziau Paul, Bazalgette Martin, Borde Antoine}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{Présentation}

L'objectif de ce projet étais d'implémenter un shell capable d'interpréter les expression de base
utilisable avec bash et d'éxétcuter des procéssus. En réalité une bonne partie du code du shell
nous été deja fournit. Tout l'aspect de l'analyse syntaxique été déja implémenté dans les fichier
donné dans le sujet.\newline

On peut diviser le travail à effectuer en 4 partie qui sont:
\begin{itemize}
 \item Implémenter la possibilité pour notre shell d'éxécuter des
 commande externe ou des progrmme en tout genre n'appartenant pas au shell
 \item Donner au shell la capacité d'interpréter les expression courante
 utilisable sous bash, comme les redirections ou les pipes
 \item Ecrire un certain nombre de commande interne (des fonctions appartennant
 au shell en lui meme) tout en faisant attention à les rendre utilisable avec
 les expressions précédement cité
 \item L'implémentation d'une commande interne "remote" qui nous permetra d'éxécuter
 et controler des shells distants en utilisant ssh.\newline 
\end{itemize}

Nous verrons au travers de ce rapport comment nous avons choisit d'implémenter ces différentes
fonctionnalité.

\newpage
\section{Commande externe}
 
 Le début de ce projet avait deja été bien entammé en tp. Nous nous somme donc
 inspiré de se qui avait été fait en classe. Nous avons créer une structure contexte
 qui contiendra a therme tout les elements dont nous auront besoin. 
 
 Ensuite nous avons implémenté une deuxieme structure assoc qui posséde un champ expr\_t
 et un pointeur de fonction reliant le type d'expréssion a la fonction de traitement
 qui lui est associé.
 
 \subsection{Commande simple en avant plan}
 
 L'éxécution de commande simple en avant plan est implémenté avec un simple fork().
 On récupére les arguments de la commande rentré et on fait un execvp de cette commande
 avec ces parametres du coté de fils. Pendant ce temps le pere attend la fin de l'éxécution
 et récupére la valeur de retour de son fils.
 
 

\newpage
\section{Expression}


\newpage
\section{Commande interne}

Dans cette partie nous avons du implémenter directement le comportement de quelques
commandes dans notre shell. Ces commandes n'etaient pas trés difficiles à implémenter. La plupart
du temps il suffisait de trouver le bon appél systeme à utilisé. A noter tout de même
que nous n'avons implémenté que les fonctionnalités de base offertes par ces commandes, nous
ne nous sommes pas amusés à ajouter la gestion de tout les paramètres, ce qui aurait 
représenté un travail trés fastidieux.

\subsection{Fonction}
\subsubsection{echo}
 La commande echo n'est rien d'autre qu'une fonction qui écrit les paramètres qu'elle reçoit
 sur la sortie standard. Un simple printf suffit pour cette commande.
 
\subsubsection{date}
 Pour cette commande nous avons du faire quelques recherches sur les fonctions fournies par time.h.
 Nous avons décidé de créer une structure tm et d'utiliser la fonction strftime qui
 sert justement à afficher l'heure selon son propre format qu'on peut définir à la volée.
 
 \subsubsection{cd}
 La commande cd à requis d'utiliser l'appel systeme chdir qui ouvre le repertoir passé en paramètre
 Nous avons veillés à récupérer la variable d'environement HOME avec getenv pour les cas ou cd est
 appellé sans paramètre. Nous avons également tenté de prévenir d'éventuels erreures(comme les
 répertoire non existant).
 
 \subsubsection{pwd}
 Cette commande appelle la fonction getcwd qui copie le chemin absolu du répertoire courant dans un buffer.
 Le buffer est initialisé avec la taille PATH_MAX, qui est une maccro du fichier limites.h, et qui correspond à la taille maximale d'un chemin. 
 Il suffit ensuite d'afficher le buffer.
 
 \subsubsection{hostname}
 Cette fonction a été implémentée d'une manière semblable à la fonction PWD.
Tout d'abord, nous avons du récupérer le nom de l'hôte local grâce à l'appel système gethostname, qui copie ce nom dans un buffer. 
La taille du buffer est initialisée à l'aide de la maccro HOST_NAME_MAX qui correspond à la taille maximale d'un nom de localhost. 
On affiche ensuite ce dernier.
 
 \subsubsection{exit}
 La commande exit permet de quitter le shell. 
 Elle peut être exécutée avec ou sans paramètres. 
 S'il n'y a pas de paramètre, on ferme le shell en renvoyant la valeur 0. 
 Sinon, on ferme le Shell en renvoyant la valeur entière du premier paramètre. Il est donc inutile de donner plusieurs paramètres à cette commande.
 
 \subsubsection{kill}
 Pour la commande kill nous avons simplement utilisé l'appel systeme kill. 
 Notre commande peut gérer le paramètre de choix de signal à envoyer. Il peut l'envoyer à tous les processus
 rentré en paramètres.
 Pour gérer l'erreur en cas d'absence de paramètres nous avons touchés directement à la valeure
 de errno la passant à EINVAL (invalid argument).
 
 \subsubsection{history}
 La commande history renvoie l'historique des commandes entrées par l'utilisateur. 
 Elle nécessite la gestion d'un historique dans le shell. 
 Pour cela il a fallu inclure le fichier history.h permettant d'utiliser un historique. 
 Pour ce faire, on appelle dans un premier temps la fonction using\_history dans le main avant la boucle principale. Ainsi on pourra utiliser les fonctions de gestions d'historique. 
 A chaque fois qu'une fonction est exécutée, elle est ajoutée à l'historique grâce à la fonction add\_history. 
 Ensuite, notre fonction history récupère la liste des fonctions appelées, et les affiche une par une. 
 On peut également exécuter la commande avec un argument n, pour afficher uniquement les n dernières commandes.
 
 \subsection{Intégration au shell}
 
 La difficultée de cette partie n'était pas tant l'implémentation des fonctions en elles mêmes,
 mais surtout le fait de rendre compatible tout ce qui avait été fait avant avec ces commandes.
 En effet les commandes internes n'utilisent pas de fork il faut donc gérer leurs comportements
 de manière particulière.

\newpage
\section{Remote shell}


\newpage
\section{Conclusion}



\end{document}
