\documentclass[12pt]{article}

\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{alltt}
\usepackage{tocbibind}


\title{Rapport Projet Programmation Système}
\author{Beziau Paul, Bazalgette Martin, Borde Antoine}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{Présentation}

L'objectif de ce projet étais d'implémenter un shell capable d'interpréter les expression de base
utilisable avec bash et d'éxétcuter des procéssus. En réalité une bonne partie du code du shell
nous été deja fournit. Tout l'aspect de l'analyse syntaxique été déja implémenté dans les fichier
donné dans le sujet.\newline

On peut diviser le travail à effectuer en 4 partie qui sont:
\begin{itemize}
 \item Implémenter la possibilité pour notre shell d'éxécuter des
 commande externe ou des progrmme en tout genre n'appartenant pas au shell
 \item Donner au shell la capacité d'interpréter les expression courante
 utilisable sous bash, comme les redirections ou les pipes
 \item Ecrire un certain nombre de commande interne (des fonctions appartennant
 au shell en lui meme) tout en faisant attention à les rendre utilisable avec
 les expressions précédement cité
 \item L'implémentation d'une commande interne "remote" qui nous permetra d'éxécuter
 et controler des shells distants en utilisant ssh.\newline 
\end{itemize}

Nous verrons au travers de ce rapport comment nous avons choisit d'implémenter ces différentes
fonctionnalité.

\newpage
\section{Commande externe}
 
 Le début de ce projet avait deja été bien entammé en tp. Nous nous somme donc
 inspiré de se qui avait été fait en classe. Nous avons créer une structure contexte
 qui contiendra a therme tout les elements dont nous auront besoin. 
 
 Ensuite nous avons implémenté une deuxieme structure assoc qui posséde un champ expr\_t
 et un pointeur de fonction reliant le type d'expréssion a la fonction de traitement
 qui lui est associé.
 
 Pour finir nous avons créer la fonction get\_expr qui retourne la fonction associé au 
 type de l'éxpréssion et l'appel en lui passant les parametres de l'éxpréssion et son 
 contexte.
 
 Ce travail préparatoire permettra de rendre beaucoup plus aisé la suite du développement
 du projet
 
 En effetl ne nous restait alors plus qu'a implémenté une fonction pour intégré le comportement
 de chaque expréssion.
 
 \subsection{Commande simple en avant plan}
 
 L'éxécution de commande simple en avant plan est implémenté avec un simple fork().
 On récupére les arguments de la commande rentré et on fait un execvp de cette commande
 avec ces parametres du coté de fils. Pendant ce temps le pere attend la fin de l'éxécution
 et récupére la valeur de retour de son fils.
 
 \subsection{Commande simple en arriére plan}
 
 Pour traité des commendes en arriére plan nous avons rajouter un champs background
 a notre structure contexte qui passe a true si le caratere \& est interprété.
 Ensuite il suffit de dire que dans se contexte on lance le fork() mais on attend pas
 fin de l'éxécution du fils.
 
 
 \subsection{Elimination des zombies}
 
 
 

\newpage
\section{Expression}

Dans cette partie, le travail consiste a implémenté l'interprétation d'expression courante
normalement utilisable avec bash tel que les redirection ">" ou les pipes "|".
En réalité ces expréssion sont déja reconnu par le shell il ne nous reste plus qu'a utilisé
nos structure pour relié chaque expréssion a son comportement spécifique et d'implémenté le
dit comportement.

Comme expliquer plus haut le gros travail préparatoire que nous avons éffectuer nous perméttra
de traité avec une relative simplicité cette partie. En effet il nous suffira la plupart du temps 
d'exploité l'arborescence deja implémenté dans le sujet, ainsi que nos structure, pour concevoir
les différents comportement

\subsection{Les séquences}

Une expréssion séquenciel consiste a exécuté la commande de gauche puis celle de droite.
Il nous suffit donc d'appeler dans l'ordre avec notre fonction get\_expr le fils gauche puis le fils
droit de notre expréssion ";"

\subsection{les expressions booleene}

Nous avons suivit le meme principe pour les expression booleene. On apelle le fils gauche puis
le fils droit de l'expression.
A la diférence que le fils droit n'est appelé que si la commande gauche a bien été éxécuter dans le
cas du "et".Et le fils droit n'est appelé que en cas d'échec du fils gauche dans le cas du "ou"

\subsection{Les sous expréssions}

Il s'agit sans doute de l'éxpréssion la plus simple a gerer. Il suffit d'appeler le fils
gauche de l'expression. La gestion de l'arborescence fera le reste.

\subsection{Les redirections}

Pour gérer les redirections nous avons rajouter dans notre structure contexte des descripteur
de fichier correspondant au entré et sortie standard des processus. Il nous suffit ensuite 
d'ouvrir le fichier passé en prametre sur les bon descripteur et d'appeler la commande.
Les entré et sortie seront ensuite remis a zero par notre fonction swapfd.

\subsection{Les pipes}

\subsection{Les expréssions recursives}


\newpage
\section{Commande interne}

Dans cette partie nous avons du implémenter directement le comportement de quelques
commandes dans notre shell. Ces commandes n'etaient pas trés difficiles à implémenter. La plupart
du temps il suffisait de trouver le bon appél systeme à utilisé. A noter tout de même
que nous n'avons implémenté que les fonctionnalités de base offertes par ces commandes, nous
ne nous sommes pas amusés à ajouter la gestion de tout les paramètres, ce qui aurait 
représenté un travail trés fastidieux.

\subsection{Fonction}
\subsubsection{echo}
 La commande echo n'est rien d'autre qu'une fonction qui écrit les paramètres qu'elle reçoit
 sur la sortie standard. Un simple printf suffit pour cette commande.
 
\subsubsection{date}
 Pour cette commande nous avons du faire quelques recherches sur les fonctions fournies par time.h.
 Nous avons décidé de créer une structure tm et d'utiliser la fonction strftime qui
 sert justement à afficher l'heure selon son propre format qu'on peut définir à la volée.
 
 \subsubsection{cd}
 La commande cd à requis d'utiliser l'appel systeme chdir qui ouvre le repertoir passé en paramètre
 Nous avons veillés à récupérer la variable d'environement HOME avec getenv pour les cas ou cd est
 appellé sans paramètre. Nous avons également tenté de prévenir d'éventuels erreures(comme les
 répertoire non existant).
 
 \subsubsection{pwd}
 Cette commande appelle la fonction getcwd qui copie le chemin absolu du répertoire 
 courant dans un buffer.
 Le buffer est initialisé avec la taille PATH\_MAX, qui est une maccro du fichier limites.h,
 et qui correspond à la taille maximale d'un chemin. Il suffit ensuite d'afficher le buffer.
 
 \subsubsection{hostname}
 Cette fonction a été implémentée d'une manière semblable à la fonction PWD.
Tout d'abord, nous avons du récupérer le nom de l'hôte local grâce à l'appel système gethostname, qui copie ce nom dans un buffer. 
La taille du buffer est initialisée à l'aide de la maccro HOST\_NAME\_MAX qui correspond à la taille maximale d'un nom de localhost. 
On affiche ensuite ce dernier.
 
 \subsubsection{exit}
 La commande exit permet de quitter le shell. 
 Elle peut être exécutée avec ou sans paramètres. 
 S'il n'y a pas de paramètre, on ferme le shell en renvoyant la valeur 0. 
 Sinon, on ferme le Shell en renvoyant la valeur entière du premier paramètre. Il est donc inutile de donner plusieurs paramètres à cette commande.
 
 \subsubsection{kill}
 Pour la commande kill nous avons simplement utilisé l'appel systeme kill. 
 Notre commande peut gérer le paramètre de choix de signal à envoyer. Il peut l'envoyer à tous les processus
 rentré en paramètres.
 Pour gérer l'erreur en cas d'absence de paramètres nous avons touchés directement à la valeure
 de errno la passant à EINVAL (invalid argument).
 
 \subsubsection{history}
 La commande history renvoie l'historique des commandes entrées par l'utilisateur. 
 Elle nécessite la gestion d'un historique dans le shell. 
 Pour cela il a fallu inclure le fichier history.h permettant d'utiliser un historique. 
 Pour ce faire, on appelle dans un premier temps la fonction using\_history dans le main avant la boucle principale. Ainsi on pourra utiliser les fonctions de gestions d'historique. 
 A chaque fois qu'une fonction est exécutée, elle est ajoutée à l'historique grâce à la fonction add\_history. 
 Ensuite, notre fonction history récupère la liste des fonctions appelées, et les affiche une par une. 
 On peut également exécuter la commande avec un argument n, pour afficher uniquement les n dernières commandes.
 
 \subsection{Intégration au shell}
 
 La difficultée de cette partie n'était pas tant l'implémentation des fonctions en elles mêmes,
 mais surtout le fait de rendre compatible tout ce qui avait été fait avant avec ces commandes.
 En effet les commandes internes n'utilisent pas de fork il faut donc gérer leurs comportements
 de manière particulière.

\newpage
\section{Remote shell}


\newpage
\section{Conclusion}



\end{document}
